# 数据缓存层详细文档

## 概述

数据缓存层负责在内存中缓存API响应数据，减少重复的API调用，提高系统性能，特别是在回测场景中。

**位置**: `src/data/cache.py`

---

## 缓存架构

### 缓存类型

系统使用**内存缓存**（In-Memory Cache），在程序运行期间保持数据。

**缓存存储结构**:
```python
class Cache:
    _prices_cache: dict[str, list[dict]]              # 价格数据缓存
    _financial_metrics_cache: dict[str, list[dict]]  # 财务指标缓存
    _line_items_cache: dict[str, list[dict]]        # 财务报表项目缓存
    _insider_trades_cache: dict[str, list[dict]]     # 内幕交易缓存
    _company_news_cache: dict[str, list[dict]]      # 公司新闻缓存
```

### 缓存键设计

**键格式**: 基于函数参数的组合字符串

**示例**:
- 价格数据: `"AAPL_2024-01-01_2024-01-31"`
- 财务指标: `"AAPL_ttm_2024-01-31_10"`
- 内幕交易: `"AAPL_2023-01-01_2024-01-31_1000"`
- 公司新闻: `"AAPL_2024-01-01_2024-01-31_100"`

**设计原则**:
- 唯一性: 不同参数组合产生不同键
- 可读性: 键包含关键参数信息
- 简洁性: 避免过长的键名

---

## 缓存操作

### 1. 获取缓存数据

**方法签名**:
```python
def get_prices(self, ticker: str) -> list[dict[str, any]] | None
def get_financial_metrics(self, ticker: str) -> list[dict[str, any]] | None
def get_line_items(self, ticker: str) -> list[dict[str, any]] | None
def get_insider_trades(self, ticker: str) -> list[dict[str, any]] | None
def get_company_news(self, ticker: str) -> list[dict[str, any]] | None
```

**行为**:
- 如果缓存中存在数据，返回数据列表
- 如果不存在，返回`None`
- 数据格式为字典列表，可直接转换为Pydantic模型

**示例**:
```python
cache = get_cache()
cached_prices = cache.get_prices("AAPL_2024-01-01_2024-01-31")
if cached_prices:
    prices = [Price(**p) for p in cached_prices]
```

---

### 2. 设置缓存数据

**方法签名**:
```python
def set_prices(self, ticker: str, data: list[dict[str, any]])
def set_financial_metrics(self, ticker: str, data: list[dict[str, any]])
def set_line_items(self, ticker: str, data: list[dict[str, any]])
def set_insider_trades(self, ticker: str, data: list[dict[str, any]])
def set_company_news(self, ticker: str, data: list[dict[str, any]])
```

**行为**:
- 将新数据合并到现有缓存中
- 自动去重（基于唯一键字段）
- 如果键不存在，创建新条目

---

## 数据合并机制

### 合并逻辑

**核心方法**: `_merge_data()`

**功能**: 合并现有数据和新数据，避免重复

**参数**:
- `existing`: 现有数据列表（可能为None）
- `new_data`: 新数据列表
- `key_field`: 用于去重的字段名

**去重字段**:
- 价格数据: `"time"` (时间戳)
- 财务指标: `"report_period"` (报告期)
- 财务报表项目: `"report_period"` (报告期)
- 内幕交易: `"filing_date"` (申报日期)
- 公司新闻: `"date"` (发布日期)

**合并算法**:
```python
def _merge_data(existing, new_data, key_field):
    if not existing:
        return new_data
    
    # 创建现有键的集合（O(1)查找）
    existing_keys = {item[key_field] for item in existing}
    
    # 只添加不存在的项
    merged = existing.copy()
    merged.extend([
        item for item in new_data 
        if item[key_field] not in existing_keys
    ])
    
    return merged
```

**优势**:
- 高效去重（O(1)查找）
- 保留历史数据
- 自动合并新数据

---

## 缓存生命周期

### 初始化

**全局单例模式**:
```python
_cache = Cache()

def get_cache() -> Cache:
    return _cache
```

**特点**:
- 单例模式确保全局唯一缓存实例
- 所有模块共享同一缓存
- 程序启动时初始化，结束时销毁

### 数据持久化

**当前实现**: **不持久化**

- 数据仅存在于内存中
- 程序重启后缓存清空
- 适合回测场景（数据可重新获取）

**未来扩展**: 可添加持久化支持
- JSON文件缓存
- SQLite数据库缓存
- Redis缓存

---

## 缓存使用流程

### 在数据获取函数中的使用

**标准流程**:
```python
def get_prices(ticker: str, start_date: str, end_date: str):
    # 1. 生成缓存键
    cache_key = f"{ticker}_{start_date}_{end_date}"
    
    # 2. 检查缓存
    cache = get_cache()
    if cached_data := cache.get_prices(cache_key):
        # 缓存命中，直接返回
        return [Price(**price) for price in cached_data]
    
    # 3. 缓存未命中，调用API
    response = make_api_request(...)
    prices = parse_response(response)
    
    # 4. 存储到缓存
    cache.set_prices(cache_key, [p.model_dump() for p in prices])
    
    # 5. 返回数据
    return prices
```

---

## 缓存性能优化

### 优势

1. **减少API调用**
   - 回测中同一数据可能被多次访问
   - 缓存避免重复网络请求
   - 降低API成本和速率限制风险

2. **提高响应速度**
   - 内存访问比网络请求快几个数量级
   - 减少延迟，提升用户体验

3. **支持离线开发**
   - 缓存数据可用于离线测试
   - 减少对网络连接的依赖

### 性能指标

**典型场景**:
- 首次获取: ~500ms (API调用)
- 缓存命中: ~1ms (内存读取)
- **性能提升**: ~500倍

---

## 缓存限制与注意事项

### 内存使用

**潜在问题**:
- 大量数据可能导致内存占用过高
- 长时间运行可能积累大量缓存数据

**缓解措施**:
- 当前实现依赖Python垃圾回收
- 可添加LRU缓存策略（未来改进）
- 可添加缓存大小限制（未来改进）

### 数据一致性

**问题**:
- 缓存数据可能不是最新的
- 财务数据有报告延迟

**解决方案**:
- 回测场景使用历史数据，一致性不是问题
- 实时场景需要定期刷新缓存
- 可添加缓存过期机制（未来改进）

### 并发安全

**当前状态**: **非线程安全**

- 单线程使用场景下安全
- 多线程场景需要加锁（未来改进）

---

## 扩展缓存功能

### 添加新的缓存类型

**步骤**:

1. **在Cache类中添加新的缓存字典**:
```python
class Cache:
    def __init__(self):
        # ... 现有缓存
        self._new_data_cache: dict[str, list[dict]] = {}
```

2. **添加getter和setter方法**:
```python
def get_new_data(self, key: str) -> list[dict] | None:
    return self._new_data_cache.get(key)

def set_new_data(self, key: str, data: list[dict]):
    existing = self._new_data_cache.get(key)
    merged = self._merge_data(existing, data, key_field="id")
    self._new_data_cache[key] = merged
```

3. **在数据获取函数中使用**:
```python
def get_new_data(...):
    cache_key = f"{...}"
    cache = get_cache()
    
    if cached := cache.get_new_data(cache_key):
        return [NewDataModel(**d) for d in cached]
    
    # API调用...
    cache.set_new_data(cache_key, [d.model_dump() for d in data])
    return data
```

---

## 缓存策略建议

### 回测场景

**推荐策略**:
- 在回测开始前预取所有需要的数据
- 利用缓存避免重复API调用
- 回测结束后缓存自动清理

**实现示例**:
```python
# 回测引擎中的预取
def _prefetch_data(self):
    for ticker in self._tickers:
        get_prices(ticker, start_date, end_date)
        get_financial_metrics(ticker, end_date)
        # ... 其他数据
```

### 实时场景

**推荐策略**:
- 使用较短的缓存过期时间
- 定期刷新关键数据
- 监控缓存命中率

---

## 调试与监控

### 查看缓存状态

**添加调试方法**:
```python
def get_cache_stats(self) -> dict:
    return {
        "prices_keys": len(self._prices_cache),
        "metrics_keys": len(self._financial_metrics_cache),
        "trades_keys": len(self._insider_trades_cache),
        "news_keys": len(self._company_news_cache),
    }
```

### 清空缓存

**添加清理方法**:
```python
def clear_cache(self):
    self._prices_cache.clear()
    self._financial_metrics_cache.clear()
    # ... 清空所有缓存
```

---

## 总结

数据缓存层通过内存缓存机制，显著提升了系统性能，特别是在回测场景中。通过智能的数据合并和去重机制，确保缓存数据的完整性和一致性。虽然当前实现较为简单，但为未来的扩展（持久化、过期策略、LRU等）留下了空间。

**核心特点**:
- ✅ 内存缓存，快速访问
- ✅ 自动去重，数据完整
- ✅ 简单易用，易于扩展
- ⚠️ 非持久化，重启丢失
- ⚠️ 无过期机制，需手动管理

