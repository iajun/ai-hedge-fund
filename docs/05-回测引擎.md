# 回测引擎详细文档

## 概述

回测引擎是系统的核心组件之一，负责模拟历史交易，评估投资策略的表现。它通过时间序列模拟，逐日执行交易决策，计算投资组合价值和性能指标。

**位置**: `src/backtesting/engine.py`

---

## 回测架构

### 核心组件

```
BacktestEngine (主控制器)
├── AgentController (智能体控制器)
├── TradeExecutor (交易执行器)
├── Portfolio (投资组合管理)
├── PerformanceMetricsCalculator (性能指标计算)
├── OutputBuilder (结果输出)
└── BenchmarkCalculator (基准对比)
```

### 数据流

```
初始化
  ↓
数据预取
  ↓
逐日循环
  ├─ 获取当日价格
  ├─ 调用智能体生成决策
  ├─ 执行交易
  ├─ 计算组合价值
  ├─ 更新性能指标
  └─ 输出结果
  ↓
计算最终指标
  ↓
返回结果
```

---

## 回测引擎初始化

### 构造函数

```python
def __init__(
    self,
    *,
    agent,                    # 智能体函数（run_hedge_fund）
    tickers: list[str],       # 股票列表
    start_date: str,          # 开始日期
    end_date: str,            # 结束日期
    initial_capital: float,    # 初始资金
    model_name: str,          # LLM模型名称
    model_provider: str,      # LLM提供商
    selected_analysts: list[str] | None,  # 选定的智能体
    initial_margin_requirement: float,     # 初始保证金要求
):
```

### 初始化组件

```python
# 1. 创建投资组合
self._portfolio = Portfolio(
    tickers=tickers,
    initial_cash=initial_capital,
    margin_requirement=initial_margin_requirement,
)

# 2. 创建交易执行器
self._executor = TradeExecutor()

# 3. 创建智能体控制器
self._agent_controller = AgentController()

# 4. 创建性能指标计算器
self._perf = PerformanceMetricsCalculator()

# 5. 创建结果输出构建器
self._results = OutputBuilder(initial_capital=self._initial_capital)

# 6. 创建基准计算器
self._benchmark = BenchmarkCalculator()

# 7. 初始化结果存储
self._portfolio_values: list[PortfolioValuePoint] = []
self._table_rows: list[list] = []
self._performance_metrics: PerformanceMetrics = {...}
```

---

## 数据预取阶段

### 预取逻辑

**位置**: `BacktestEngine._prefetch_data()`

```python
def _prefetch_data(self) -> None:
    """预取所有需要的数据到缓存"""
    
    # 计算数据范围（提前1年获取，用于分析）
    end_date_dt = datetime.strptime(self._end_date, "%Y-%m-%d")
    start_date_dt = end_date_dt - relativedelta(years=1)
    start_date_str = start_date_dt.strftime("%Y-%m-%d")
    
    # 对每个ticker预取数据
    for ticker in self._tickers:
        # 价格数据（提前1年）
        get_prices(ticker, start_date_str, self._end_date)
        
        # 财务指标（最近10期）
        get_financial_metrics(ticker, self._end_date, limit=10)
        
        # 内幕交易（回测期间）
        get_insider_trades(
            ticker, 
            self._end_date, 
            start_date=self._start_date, 
            limit=1000
        )
        
        # 公司新闻（回测期间）
        get_company_news(
            ticker, 
            self._end_date, 
            start_date=self._start_date, 
            limit=1000
        )
    
    # 预取基准数据（SPY）
    get_prices("SPY", self._start_date, self._end_date)
```

### 预取优势

1. **提前加载**: 避免回测过程中的API调用延迟
2. **缓存利用**: 数据存入缓存，后续访问快速
3. **错误提前发现**: 数据问题在回测开始前发现

---

## 回测主循环

### 日期生成

```python
# 生成交易日序列（工作日）
dates = pd.date_range(self._start_date, self._end_date, freq="B")

# 初始化组合价值序列
self._portfolio_values = [
    {"Date": dates[0], "Portfolio Value": self._initial_capital}
]
```

### 逐日循环

```python
for current_date in dates:
    # 1. 计算回看窗口
    lookback_start = (current_date - relativedelta(months=1)).strftime("%Y-%m-%d")
    current_date_str = current_date.strftime("%Y-%m-%d")
    previous_date_str = (current_date - relativedelta(days=1)).strftime("%Y-%m-%d")
    
    # 2. 获取当日价格
    current_prices = {}
    for ticker in self._tickers:
        price_data = get_price_data(ticker, previous_date_str, current_date_str)
        if price_data.empty:
            continue  # 跳过无数据日期
        current_prices[ticker] = float(price_data.iloc[-1]["close"])
    
    # 3. 调用智能体生成决策
    agent_output = self._agent_controller.run_agent(
        self._agent,
        tickers=self._tickers,
        start_date=lookback_start,      # 回看1个月
        end_date=current_date_str,       # 当前日期
        portfolio=self._portfolio,
        model_name=self._model_name,
        model_provider=self._model_provider,
        selected_analysts=self._selected_analysts,
    )
    
    # 4. 执行交易
    decisions = agent_output["decisions"]
    executed_trades = {}
    for ticker in self._tickers:
        d = decisions.get(ticker, {"action": "hold", "quantity": 0})
        action = d.get("action", "hold")
        qty = d.get("quantity", 0)
        executed_qty = self._executor.execute_trade(
            ticker, action, qty, 
            current_prices[ticker], 
            self._portfolio
        )
        executed_trades[ticker] = executed_qty
    
    # 5. 计算组合价值
    total_value = calculate_portfolio_value(self._portfolio, current_prices)
    
    # 6. 计算敞口
    exposures = compute_exposures(self._portfolio, current_prices)
    
    # 7. 记录组合价值点
    point: PortfolioValuePoint = {
        "Date": current_date,
        "Portfolio Value": total_value,
        "Long Exposure": exposures["Long Exposure"],
        "Short Exposure": exposures["Short Exposure"],
        "Gross Exposure": exposures["Gross Exposure"],
        "Net Exposure": exposures["Net Exposure"],
        "Long/Short Ratio": exposures["Long/Short Ratio"],
    }
    self._portfolio_values.append(point)
    
    # 8. 构建输出行
    rows = self._results.build_day_rows(
        date_str=current_date_str,
        tickers=self._tickers,
        agent_output=agent_output,
        executed_trades=executed_trades,
        current_prices=current_prices,
        portfolio=self._portfolio,
        performance_metrics=self._performance_metrics,
        total_value=total_value,
        benchmark_return_pct=self._benchmark.get_return_pct(
            "SPY", self._start_date, current_date_str
        ),
    )
    
    # 9. 输出结果（最新日期在前）
    self._table_rows = rows + self._table_rows
    self._results.print_rows(self._table_rows)
    
    # 10. 更新性能指标
    if len(self._portfolio_values) > 3:
        computed = self._perf.compute_metrics(self._portfolio_values)
        if computed:
            self._performance_metrics.update(computed)
```

---

## 智能体控制器

### AgentController

**位置**: `src/backtesting/controller.py`

**功能**: 调用智能体并规范化输出

```python
class AgentController:
    def run_agent(
        self,
        agent: Callable,
        *,
        tickers: Sequence[str],
        start_date: str,
        end_date: str,
        portfolio: Portfolio | PortfolioSnapshot,
        model_name: str,
        model_provider: str,
        selected_analysts: Sequence[str] | None,
    ) -> AgentOutput:
        # 1. 转换投资组合为快照
        if isinstance(portfolio, Portfolio):
            portfolio_payload = portfolio.get_snapshot()
        else:
            portfolio_payload = portfolio
        
        # 2. 调用智能体
        output = agent(
            tickers=list(tickers),
            start_date=start_date,
            end_date=end_date,
            portfolio=portfolio_payload,
            model_name=model_name,
            model_provider=model_provider,
            selected_analysts=list(selected_analysts) if selected_analysts else None,
        )
        
        # 3. 规范化输出
        decisions_in = dict(output.get("decisions", {}))
        analyst_signals_in = dict(output.get("analyst_signals", {}))
        
        normalized_decisions: AgentDecisions = {}
        for ticker in tickers:
            d = decisions_in.get(ticker, {})
            action = d.get("action", "hold")
            qty = d.get("quantity", 0)
            
            # 类型转换和验证
            try:
                qty_val = float(qty)
            except Exception:
                qty_val = 0.0
            
            try:
                action = Action(action).value  # 验证action
            except Exception:
                action = Action.HOLD.value
            
            normalized_decisions[ticker] = {
                "action": action, 
                "quantity": qty_val
            }
        
        # 4. 返回规范化输出
        return {
            "decisions": normalized_decisions,
            "analyst_signals": analyst_signals_in,
        }
```

---

## 交易执行器

### TradeExecutor

**位置**: `src/backtesting/trader.py`

**功能**: 执行交易并更新投资组合

```python
class TradeExecutor:
    def execute_trade(
        self,
        ticker: str,
        action: ActionLiteral,      # "buy", "sell", "short", "cover", "hold"
        quantity: float,
        current_price: float,
        portfolio: Portfolio,
    ) -> int:
        """执行交易，返回实际执行的股数"""
        
        if quantity is None or quantity <= 0:
            return 0
        
        # 转换为Action枚举
        action_enum = Action(action) if not isinstance(action, Action) else action
        
        # 根据操作类型执行
        if action_enum == Action.BUY:
            return portfolio.apply_long_buy(ticker, int(quantity), float(current_price))
        if action_enum == Action.SELL:
            return portfolio.apply_long_sell(ticker, int(quantity), float(current_price))
        if action_enum == Action.SHORT:
            return portfolio.apply_short_open(ticker, int(quantity), float(current_price))
        if action_enum == Action.COVER:
            return portfolio.apply_short_cover(ticker, int(quantity), float(current_price))
        
        # hold或未知操作
        return 0
```

---

## 投资组合管理

### Portfolio类

**位置**: `src/backtesting/portfolio.py`

**核心方法**:

#### 1. 买入（Long Buy）

```python
def apply_long_buy(self, ticker: str, quantity: int, price: float) -> int:
    """买入股票"""
    if quantity <= 0:
        return 0
    
    position = self._portfolio["positions"][ticker]
    cost = quantity * price
    
    # 检查现金是否足够
    if cost <= self._portfolio["cash"]:
        # 更新持仓
        old_shares = position["long"]
        old_cost_basis = position["long_cost_basis"]
        total_shares = old_shares + quantity
        
        # 计算新的成本基础（加权平均）
        if total_shares > 0:
            total_old_cost = old_cost_basis * old_shares
            total_new_cost = cost
            position["long_cost_basis"] = (total_old_cost + total_new_cost) / total_shares
        
        position["long"] = total_shares
        self._portfolio["cash"] -= cost
        return quantity
    
    # 现金不足，买入最大可买数量
    max_quantity = int(self._portfolio["cash"] / price) if price > 0 else 0
    if max_quantity > 0:
        # 执行部分买入
        # ... 类似逻辑 ...
        return max_quantity
    
    return 0
```

#### 2. 卖出（Long Sell）

```python
def apply_long_sell(self, ticker: str, quantity: int, price: float) -> int:
    """卖出股票"""
    position = self._portfolio["positions"][ticker]
    quantity = min(int(quantity), position["long"]) if quantity > 0 else 0
    
    if quantity <= 0:
        return 0
    
    # 计算已实现收益
    avg_cost = position["long_cost_basis"] if position["long"] > 0 else 0.0
    realized_gain = (price - avg_cost) * quantity
    
    # 更新持仓
    position["long"] -= quantity
    self._portfolio["cash"] += quantity * price
    
    # 记录已实现收益
    self._portfolio["realized_gains"][ticker]["long"] += realized_gain
    
    # 如果全部卖出，重置成本基础
    if position["long"] == 0:
        position["long_cost_basis"] = 0.0
    
    return quantity
```

#### 3. 做空（Short Open）

```python
def apply_short_open(self, ticker: str, quantity: int, price: float) -> int:
    """开仓做空"""
    if quantity <= 0:
        return 0
    
    position = self._portfolio["positions"][ticker]
    proceeds = price * quantity
    margin_ratio = self._portfolio["margin_requirement"]
    margin_required = proceeds * margin_ratio
    
    # 检查保证金是否足够
    if margin_required <= self._portfolio["cash"]:
        # 更新空头持仓
        old_short_shares = position["short"]
        old_cost_basis = position["short_cost_basis"]
        total_shares = old_short_shares + quantity
        
        # 计算新的成本基础
        if total_shares > 0:
            total_old_cost = old_cost_basis * old_short_shares
            total_new_cost = price * quantity
            position["short_cost_basis"] = (total_old_cost + total_new_cost) / total_shares
        
        position["short"] = total_shares
        position["short_margin_used"] += margin_required
        self._portfolio["margin_used"] += margin_required
        
        # 做空收入现金，但需要冻结保证金
        self._portfolio["cash"] += proceeds
        self._portfolio["cash"] -= margin_required
        
        return quantity
    
    # 保证金不足，计算最大可做空数量
    # ... 类似逻辑 ...
    return 0
```

#### 4. 平仓（Short Cover）

```python
def apply_short_cover(self, ticker: str, quantity: int, price: float) -> int:
    """平仓做空"""
    position = self._portfolio["positions"][ticker]
    quantity = min(int(quantity), position["short"]) if quantity > 0 else 0
    
    if quantity <= 0:
        return 0
    
    cover_cost = quantity * price
    avg_short_price = position["short_cost_basis"] if position["short"] > 0 else 0.0
    
    # 计算已实现收益（做空收益 = 开仓价 - 平仓价）
    realized_gain = (avg_short_price - price) * quantity
    
    # 释放保证金
    if position["short"] > 0:
        portion = quantity / position["short"]
    else:
        portion = 1.0
    margin_to_release = portion * position["short_margin_used"]
    
    # 更新持仓
    position["short"] -= quantity
    position["short_margin_used"] -= margin_to_release
    self._portfolio["margin_used"] -= margin_to_release
    
    # 更新现金（释放保证金，支付平仓成本）
    self._portfolio["cash"] += margin_to_release
    self._portfolio["cash"] -= cover_cost
    
    # 记录已实现收益
    self._portfolio["realized_gains"][ticker]["short"] += realized_gain
    
    # 如果全部平仓，重置
    if position["short"] == 0:
        position["short_cost_basis"] = 0.0
        position["short_margin_used"] = 0.0
    
    return quantity
```

---

## 组合价值计算

### calculate_portfolio_value()

**位置**: `src/backtesting/valuation.py`

```python
def calculate_portfolio_value(
    portfolio: Portfolio | PortfolioSnapshot,
    current_prices: dict[str, float]
) -> float:
    """计算投资组合总价值（净清算价值）"""
    
    total_value = portfolio.get("cash", 0.0)
    positions = portfolio.get("positions", {})
    
    for ticker, position in positions.items():
        if ticker in current_prices:
            price = current_prices[ticker]
            
            # 多头持仓价值
            long_value = position.get("long", 0) * price
            total_value += long_value
            
            # 空头持仓价值（负值）
            short_value = position.get("short", 0) * price
            total_value -= short_value
    
    return total_value
```

### compute_exposures()

**位置**: `src/backtesting/valuation.py`

```python
def compute_exposures(
    portfolio: Portfolio | PortfolioSnapshot,
    current_prices: dict[str, float]
) -> dict[str, float]:
    """计算投资组合敞口"""
    
    long_exposure = 0.0
    short_exposure = 0.0
    
    positions = portfolio.get("positions", {})
    for ticker, position in positions.items():
        if ticker in current_prices:
            price = current_prices[ticker]
            long_exposure += position.get("long", 0) * price
            short_exposure += position.get("short", 0) * price
    
    gross_exposure = long_exposure + short_exposure
    net_exposure = long_exposure - short_exposure
    
    long_short_ratio = (
        long_exposure / short_exposure 
        if short_exposure > 0 
        else (float("inf") if long_exposure > 0 else 0.0)
    )
    
    return {
        "Long Exposure": long_exposure,
        "Short Exposure": short_exposure,
        "Gross Exposure": gross_exposure,
        "Net Exposure": net_exposure,
        "Long/Short Ratio": long_short_ratio,
    }
```

---

## 性能指标计算

### PerformanceMetricsCalculator

**位置**: `src/backtesting/metrics.py`

**计算的指标**:

#### 1. Sharpe比率

```python
# 计算日收益率
daily_returns = df["Portfolio Value"].pct_change()

# 计算超额收益（相对于无风险利率）
daily_rf = annual_rf_rate / annual_trading_days  # 默认4.34%年化
excess = daily_returns - daily_rf

# Sharpe = (平均超额收益 / 超额收益标准差) * sqrt(252)
mean_excess = excess.mean()
std_excess = excess.std()
sharpe = np.sqrt(252) * (mean_excess / std_excess)
```

#### 2. Sortino比率

```python
# 只考虑下行波动
negative_excess = excess[excess < 0]
downside_std = negative_excess.std()

# Sortino = (平均超额收益 / 下行标准差) * sqrt(252)
sortino = np.sqrt(252) * (mean_excess / downside_std)
```

#### 3. 最大回撤

```python
# 计算累计最大值
rolling_max = df["Portfolio Value"].cummax()

# 计算回撤
drawdown = (df["Portfolio Value"] - rolling_max) / rolling_max

# 最大回撤
max_drawdown = drawdown.min() * 100.0  # 转换为百分比
max_drawdown_date = drawdown.idxmin()
```

---

## 基准对比

### BenchmarkCalculator

**位置**: `src/backtesting/benchmarks.py`

**功能**: 计算基准指数（如SPY）的收益率，用于对比

```python
def get_return_pct(self, ticker: str, start_date: str, end_date: str) -> float:
    """计算基准指数的收益率百分比"""
    prices = get_prices(ticker, start_date, end_date)
    if len(prices) < 2:
        return 0.0
    
    start_price = prices[0].close
    end_price = prices[-1].close
    return ((end_price - start_price) / start_price) * 100.0
```

---

## 结果输出

### OutputBuilder

**位置**: `src/backtesting/output.py`

**功能**: 构建和格式化回测结果输出

**输出内容**:
- 每日交易记录
- 持仓变化
- 组合价值变化
- 性能指标
- 与基准对比

---

## 回测执行示例

### 完整流程

```python
# 1. 创建回测引擎
backtester = BacktestEngine(
    agent=run_hedge_fund,
    tickers=["AAPL", "MSFT", "NVDA"],
    start_date="2024-01-01",
    end_date="2024-01-31",
    initial_capital=100000.0,
    model_name="gpt-4.1",
    model_provider="OpenAI",
    selected_analysts=["warren_buffett", "cathie_wood"],
    initial_margin_requirement=0.5,
)

# 2. 运行回测
performance_metrics = backtester.run_backtest()

# 3. 获取结果
portfolio_values = backtester.get_portfolio_values()

# 4. 查看性能指标
print(f"Sharpe Ratio: {performance_metrics['sharpe_ratio']}")
print(f"Max Drawdown: {performance_metrics['max_drawdown']}%")
```

---

## 总结

回测引擎通过时间序列模拟，逐日执行交易决策，完整模拟了投资策略的历史表现。通过组件化设计，实现了交易执行、组合管理、性能计算等功能，为策略评估提供了全面的支持。

**核心特点**:
- ✅ 完整的时间序列模拟
- ✅ 真实的交易执行逻辑
- ✅ 全面的性能指标计算
- ✅ 基准对比功能
- ✅ 详细的输出和可视化

